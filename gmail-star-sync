#!/usr/bin/env ruby

require 'google/api_client'
require 'google/api_client/client_secrets'
require 'google/api_client/auth/installed_app'
require 'google/api_client/auth/storage'
require 'google/api_client/auth/storages/file_store'
require 'fileutils'
require 'pry'

APPLICATION_NAME = 'Gmail Star Sync'
CLIENT_SECRETS_PATH = 'client_secret.json'
CREDENTIALS_PATH = File.join(Dir.home, '.credentials',
                             "gmail-star-sync.json")
# SCOPE = 'https://www.googleapis.com/auth/gmail.readonly'
# SCOPE = 'https://www.googleapis.com/auth/gmail.labels'
SCOPE = 'https://www.googleapis.com/auth/gmail.modify'

##
# Ensure valid credentials, either by restoring from the saved credentials
# files or intitiating an OAuth2 authorization request via InstalledAppFlow.
# If authorization is required, the user's default browser will be launched
# to approve the request.
#
# @return [Signet::OAuth2::Client] OAuth2 credentials
def authorize
  FileUtils.mkdir_p(File.dirname(CREDENTIALS_PATH))

  file_store = Google::APIClient::FileStore.new(CREDENTIALS_PATH)
  storage = Google::APIClient::Storage.new(file_store)
  auth = storage.authorize

  if auth.nil? || (auth.expired? && auth.refresh_token.nil?)
    app_info = Google::APIClient::ClientSecrets.load(CLIENT_SECRETS_PATH)
    flow = Google::APIClient::InstalledAppFlow.new({
      :client_id => app_info.client_id,
      :client_secret => app_info.client_secret,
      :scope => SCOPE})
    auth = flow.authorize(storage)
    puts "Credentials saved to #{CREDENTIALS_PATH}" unless auth.nil?
  end
  auth
end

# Initialize the API
client = Google::APIClient.new(:application_name => APPLICATION_NAME)
client.authorization = authorize
gmail_api = client.discovered_api('gmail', 'v1')

# Show the user's labels
# results = client.execute!(
#   :api_method => gmail_api.users.labels.list,
#   :parameters => { :userId => 'me' })

# puts "Labels:"
# puts "No labels found" if results.data.labels.empty?
# results.data.labels.each { |label| puts "- #{label.name}" }

puts "Loading starred threads"
results = client.execute!(
  :api_method => gmail_api.users.threads.list,
  :parameters => {
    :userId => 'me',
    labelIds: [ "STARRED" ]
    })

threads = results.data.threads

# Debug
# threads = [ threads.first ]

threads = threads.map do |thread|
  t = client.execute!( api_method: gmail_api.users.threads.get, parameters: { userId: 'me', id: thread.id } )
  subject = t.data.messages.first.payload.headers.select{|h| h.name == "Subject" }.map{|h| h.value}.first
  subject.gsub!("'","")
  puts "Loaded thread: #{subject}"
  { id: thread.id, subject: subject }
end

# Now go through and add/remove these to TW!
# * Look for task matching subject (or thread id?)
# * If done, clear star
# * if nothing found, create

# Get list of UUIDs for +email tasks
# If any of these are not on the list, we should mark them as done
# because they must not be starred anymore!

existing_uuids = `task status:pending +email uuids`.split(' ')
pending_starred_uuids  = []


threads.each do |thread|
  id = thread[:id]
  subject = thread[:subject]
  puts "Processing thread: #{subject}"
  # subject.gsub!('[', '[')
  uuid = `task description.is:'#{subject}' uuids`.chomp
  if uuid.empty?
    puts "Creating task"
    `task add proj:work +email -- '#{subject}'`
    uuid = `task description.is:'#{subject}' uuids`.chomp
  end
  status = `task _get #{uuid}.status`.chomp
  puts "UUID: #{uuid}\nStatus: #{status}"
  pending_starred_uuids << uuid if status == "pending"
  if status == 'completed'
    puts "Task complete, removing star"
    client.execute!(
      :api_method => gmail_api.users.threads.modify,
      :parameters => {
        userId: 'me',
        id: id,
      },
      body_object: {
        addLabelIds: [],
        removeLabelIds: [ "STARRED" ]
      }
    )
  end
end

existing_uuids.each do |uuid|
  next if pending_starred_uuids.include?(uuid)
  `task #{uuid} done`
  puts "Marked #{uuid} done"
end

